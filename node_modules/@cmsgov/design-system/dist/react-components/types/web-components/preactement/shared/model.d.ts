import { Signal } from '@preact/signals';
type IComponent = any;
interface IOptions<F = any, W = any> {
    attributes?: readonly string[];
    /**
     * For simple events whose React-prop counterparts are callback functions that pass a
     * simple event object, the name of the React prop will suffice to configure the
     * mapping between React prop and custom event. However, not all of our React
     * components pass just an event to their callback props. Some don't pass an event at
     * all or need to convey additional information, like a page number or selected item.
     * In those special cases, you can supply a name and a function that will take the
     * React callback parameters and return an event-like object that will be used to
     * create the custom event.
     */
    events?: Array<string | readonly [string, (...args: any[]) => CustomEventInit<unknown>]>;
    formatProps?: (props: any) => F;
    wrapComponent?: (child: any) => W;
}
declare enum ErrorTypes {
    Promise = "Error: Promises cannot be used for SSR",
    Missing = "Error: Cannot find component in provided function",
    Json = "Error: Invalid JSON string passed to component",
    Tag = "Error: Invalid tag name for custom element. Must include a `-`"
}
interface CustomElement<CF = any, C = any> extends HTMLElement {
    __mounted: boolean;
    __componentFunction: CF;
    __component?: C;
    __properties?: IProps;
    __events?: IProps;
    __options: IOptions;
    __mutationObserver?: MutationObserver;
    __propsSignal: Signal;
    renderPreactComponent(addedNodes?: Node[]): void;
}
interface IProps {
    [index: string]: any;
}
declare const isPromise: (input: any) => input is Promise<any>;
declare const selfClosingTags: string[];
export { IComponent, IOptions, IProps, ErrorTypes, CustomElement, isPromise, selfClosingTags };
